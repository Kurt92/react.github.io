{"ast":null,"code":"/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.1.3): carousel.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\nimport { defineJQueryPlugin, getElementFromSelector, isRTL, isVisible, getNextActiveElement, reflow, triggerTransitionEnd, typeCheckConfig } from './util/index';\nimport EventHandler from './dom/event-handler';\nimport Manipulator from './dom/manipulator';\nimport SelectorEngine from './dom/selector-engine';\nimport BaseComponent from './base-component';\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME = 'carousel';\nconst DATA_KEY = 'bs.carousel';\nconst EVENT_KEY = `.${DATA_KEY}`;\nconst DATA_API_KEY = '.data-api';\nconst ARROW_LEFT_KEY = 'ArrowLeft';\nconst ARROW_RIGHT_KEY = 'ArrowRight';\nconst TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n\nconst SWIPE_THRESHOLD = 40;\nconst Default = {\n  interval: 5000,\n  keyboard: true,\n  slide: false,\n  pause: 'hover',\n  wrap: true,\n  touch: true\n};\nconst DefaultType = {\n  interval: '(number|boolean)',\n  keyboard: 'boolean',\n  slide: '(boolean|string)',\n  pause: '(string|boolean)',\n  wrap: 'boolean',\n  touch: 'boolean'\n};\nconst ORDER_NEXT = 'next';\nconst ORDER_PREV = 'prev';\nconst DIRECTION_LEFT = 'left';\nconst DIRECTION_RIGHT = 'right';\nconst KEY_TO_DIRECTION = {\n  [ARROW_LEFT_KEY]: DIRECTION_RIGHT,\n  [ARROW_RIGHT_KEY]: DIRECTION_LEFT\n};\nconst EVENT_SLIDE = `slide${EVENT_KEY}`;\nconst EVENT_SLID = `slid${EVENT_KEY}`;\nconst EVENT_KEYDOWN = `keydown${EVENT_KEY}`;\nconst EVENT_MOUSEENTER = `mouseenter${EVENT_KEY}`;\nconst EVENT_MOUSELEAVE = `mouseleave${EVENT_KEY}`;\nconst EVENT_TOUCHSTART = `touchstart${EVENT_KEY}`;\nconst EVENT_TOUCHMOVE = `touchmove${EVENT_KEY}`;\nconst EVENT_TOUCHEND = `touchend${EVENT_KEY}`;\nconst EVENT_POINTERDOWN = `pointerdown${EVENT_KEY}`;\nconst EVENT_POINTERUP = `pointerup${EVENT_KEY}`;\nconst EVENT_DRAG_START = `dragstart${EVENT_KEY}`;\nconst EVENT_LOAD_DATA_API = `load${EVENT_KEY}${DATA_API_KEY}`;\nconst EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`;\nconst CLASS_NAME_CAROUSEL = 'carousel';\nconst CLASS_NAME_ACTIVE = 'active';\nconst CLASS_NAME_SLIDE = 'slide';\nconst CLASS_NAME_END = 'carousel-item-end';\nconst CLASS_NAME_START = 'carousel-item-start';\nconst CLASS_NAME_NEXT = 'carousel-item-next';\nconst CLASS_NAME_PREV = 'carousel-item-prev';\nconst CLASS_NAME_POINTER_EVENT = 'pointer-event';\nconst SELECTOR_ACTIVE = '.active';\nconst SELECTOR_ACTIVE_ITEM = '.active.carousel-item';\nconst SELECTOR_ITEM = '.carousel-item';\nconst SELECTOR_ITEM_IMG = '.carousel-item img';\nconst SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev';\nconst SELECTOR_INDICATORS = '.carousel-indicators';\nconst SELECTOR_INDICATOR = '[data-bs-target]';\nconst SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';\nconst SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]';\nconst POINTER_TYPE_TOUCH = 'touch';\nconst POINTER_TYPE_PEN = 'pen';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Carousel extends BaseComponent {\n  constructor(element, config) {\n    super(element);\n    this._items = null;\n    this._interval = null;\n    this._activeElement = null;\n    this._isPaused = false;\n    this._isSliding = false;\n    this.touchTimeout = null;\n    this.touchStartX = 0;\n    this.touchDeltaX = 0;\n    this._config = this._getConfig(config);\n    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);\n    this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\n    this._pointerEvent = Boolean(window.PointerEvent);\n\n    this._addEventListeners();\n  } // Getters\n\n\n  static get Default() {\n    return Default;\n  }\n\n  static get NAME() {\n    return NAME;\n  } // Public\n\n\n  next() {\n    this._slide(ORDER_NEXT);\n  }\n\n  nextWhenVisible() {\n    // Don't call next when the page isn't visible\n    // or the carousel or its parent isn't visible\n    if (!document.hidden && isVisible(this._element)) {\n      this.next();\n    }\n  }\n\n  prev() {\n    this._slide(ORDER_PREV);\n  }\n\n  pause(event) {\n    if (!event) {\n      this._isPaused = true;\n    }\n\n    if (SelectorEngine.findOne(SELECTOR_NEXT_PREV, this._element)) {\n      triggerTransitionEnd(this._element);\n      this.cycle(true);\n    }\n\n    clearInterval(this._interval);\n    this._interval = null;\n  }\n\n  cycle(event) {\n    if (!event) {\n      this._isPaused = false;\n    }\n\n    if (this._interval) {\n      clearInterval(this._interval);\n      this._interval = null;\n    }\n\n    if (this._config && this._config.interval && !this._isPaused) {\n      this._updateInterval();\n\n      this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);\n    }\n  }\n\n  to(index) {\n    this._activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n\n    const activeIndex = this._getItemIndex(this._activeElement);\n\n    if (index > this._items.length - 1 || index < 0) {\n      return;\n    }\n\n    if (this._isSliding) {\n      EventHandler.one(this._element, EVENT_SLID, () => this.to(index));\n      return;\n    }\n\n    if (activeIndex === index) {\n      this.pause();\n      this.cycle();\n      return;\n    }\n\n    const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\n\n    this._slide(order, this._items[index]);\n  } // Private\n\n\n  _getConfig(config) {\n    config = { ...Default,\n      ...Manipulator.getDataAttributes(this._element),\n      ...(typeof config === 'object' ? config : {})\n    };\n    typeCheckConfig(NAME, config, DefaultType);\n    return config;\n  }\n\n  _handleSwipe() {\n    const absDeltax = Math.abs(this.touchDeltaX);\n\n    if (absDeltax <= SWIPE_THRESHOLD) {\n      return;\n    }\n\n    const direction = absDeltax / this.touchDeltaX;\n    this.touchDeltaX = 0;\n\n    if (!direction) {\n      return;\n    }\n\n    this._slide(direction > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT);\n  }\n\n  _addEventListeners() {\n    if (this._config.keyboard) {\n      EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));\n    }\n\n    if (this._config.pause === 'hover') {\n      EventHandler.on(this._element, EVENT_MOUSEENTER, event => this.pause(event));\n      EventHandler.on(this._element, EVENT_MOUSELEAVE, event => this.cycle(event));\n    }\n\n    if (this._config.touch && this._touchSupported) {\n      this._addTouchEventListeners();\n    }\n  }\n\n  _addTouchEventListeners() {\n    const hasPointerPenTouch = event => {\n      return this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);\n    };\n\n    const start = event => {\n      if (hasPointerPenTouch(event)) {\n        this.touchStartX = event.clientX;\n      } else if (!this._pointerEvent) {\n        this.touchStartX = event.touches[0].clientX;\n      }\n    };\n\n    const move = event => {\n      // ensure swiping with one touch and not pinching\n      this.touchDeltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this.touchStartX;\n    };\n\n    const end = event => {\n      if (hasPointerPenTouch(event)) {\n        this.touchDeltaX = event.clientX - this.touchStartX;\n      }\n\n      this._handleSwipe();\n\n      if (this._config.pause === 'hover') {\n        // If it's a touch-enabled device, mouseenter/leave are fired as\n        // part of the mouse compatibility events on first tap - the carousel\n        // would stop cycling until user tapped out of it;\n        // here, we listen for touchend, explicitly pause the carousel\n        // (as if it's the second time we tap on it, mouseenter compat event\n        // is NOT fired) and after a timeout (to allow for mouse compatibility\n        // events to fire) we explicitly restart cycling\n        this.pause();\n\n        if (this.touchTimeout) {\n          clearTimeout(this.touchTimeout);\n        }\n\n        this.touchTimeout = setTimeout(event => this.cycle(event), TOUCHEVENT_COMPAT_WAIT + this._config.interval);\n      }\n    };\n\n    SelectorEngine.find(SELECTOR_ITEM_IMG, this._element).forEach(itemImg => {\n      EventHandler.on(itemImg, EVENT_DRAG_START, event => event.preventDefault());\n    });\n\n    if (this._pointerEvent) {\n      EventHandler.on(this._element, EVENT_POINTERDOWN, event => start(event));\n      EventHandler.on(this._element, EVENT_POINTERUP, event => end(event));\n\n      this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n    } else {\n      EventHandler.on(this._element, EVENT_TOUCHSTART, event => start(event));\n      EventHandler.on(this._element, EVENT_TOUCHMOVE, event => move(event));\n      EventHandler.on(this._element, EVENT_TOUCHEND, event => end(event));\n    }\n  }\n\n  _keydown(event) {\n    if (/input|textarea/i.test(event.target.tagName)) {\n      return;\n    }\n\n    const direction = KEY_TO_DIRECTION[event.key];\n\n    if (direction) {\n      event.preventDefault();\n\n      this._slide(direction);\n    }\n  }\n\n  _getItemIndex(element) {\n    this._items = element && element.parentNode ? SelectorEngine.find(SELECTOR_ITEM, element.parentNode) : [];\n    return this._items.indexOf(element);\n  }\n\n  _getItemByOrder(order, activeElement) {\n    const isNext = order === ORDER_NEXT;\n    return getNextActiveElement(this._items, activeElement, isNext, this._config.wrap);\n  }\n\n  _triggerSlideEvent(relatedTarget, eventDirectionName) {\n    const targetIndex = this._getItemIndex(relatedTarget);\n\n    const fromIndex = this._getItemIndex(SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element));\n\n    return EventHandler.trigger(this._element, EVENT_SLIDE, {\n      relatedTarget,\n      direction: eventDirectionName,\n      from: fromIndex,\n      to: targetIndex\n    });\n  }\n\n  _setActiveIndicatorElement(element) {\n    if (this._indicatorsElement) {\n      const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);\n      activeIndicator.classList.remove(CLASS_NAME_ACTIVE);\n      activeIndicator.removeAttribute('aria-current');\n      const indicators = SelectorEngine.find(SELECTOR_INDICATOR, this._indicatorsElement);\n\n      for (let i = 0; i < indicators.length; i++) {\n        if (Number.parseInt(indicators[i].getAttribute('data-bs-slide-to'), 10) === this._getItemIndex(element)) {\n          indicators[i].classList.add(CLASS_NAME_ACTIVE);\n          indicators[i].setAttribute('aria-current', 'true');\n          break;\n        }\n      }\n    }\n  }\n\n  _updateInterval() {\n    const element = this._activeElement || SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n\n    if (!element) {\n      return;\n    }\n\n    const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);\n\n    if (elementInterval) {\n      this._config.defaultInterval = this._config.defaultInterval || this._config.interval;\n      this._config.interval = elementInterval;\n    } else {\n      this._config.interval = this._config.defaultInterval || this._config.interval;\n    }\n  }\n\n  _slide(directionOrOrder, element) {\n    const order = this._directionToOrder(directionOrOrder);\n\n    const activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n\n    const activeElementIndex = this._getItemIndex(activeElement);\n\n    const nextElement = element || this._getItemByOrder(order, activeElement);\n\n    const nextElementIndex = this._getItemIndex(nextElement);\n\n    const isCycling = Boolean(this._interval);\n    const isNext = order === ORDER_NEXT;\n    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\n    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\n\n    const eventDirectionName = this._orderToDirection(order);\n\n    if (nextElement && nextElement.classList.contains(CLASS_NAME_ACTIVE)) {\n      this._isSliding = false;\n      return;\n    }\n\n    if (this._isSliding) {\n      return;\n    }\n\n    const slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);\n\n    if (slideEvent.defaultPrevented) {\n      return;\n    }\n\n    if (!activeElement || !nextElement) {\n      // Some weirdness is happening, so we bail\n      return;\n    }\n\n    this._isSliding = true;\n\n    if (isCycling) {\n      this.pause();\n    }\n\n    this._setActiveIndicatorElement(nextElement);\n\n    this._activeElement = nextElement;\n\n    const triggerSlidEvent = () => {\n      EventHandler.trigger(this._element, EVENT_SLID, {\n        relatedTarget: nextElement,\n        direction: eventDirectionName,\n        from: activeElementIndex,\n        to: nextElementIndex\n      });\n    };\n\n    if (this._element.classList.contains(CLASS_NAME_SLIDE)) {\n      nextElement.classList.add(orderClassName);\n      reflow(nextElement);\n      activeElement.classList.add(directionalClassName);\n      nextElement.classList.add(directionalClassName);\n\n      const completeCallBack = () => {\n        nextElement.classList.remove(directionalClassName, orderClassName);\n        nextElement.classList.add(CLASS_NAME_ACTIVE);\n        activeElement.classList.remove(CLASS_NAME_ACTIVE, orderClassName, directionalClassName);\n        this._isSliding = false;\n        setTimeout(triggerSlidEvent, 0);\n      };\n\n      this._queueCallback(completeCallBack, activeElement, true);\n    } else {\n      activeElement.classList.remove(CLASS_NAME_ACTIVE);\n      nextElement.classList.add(CLASS_NAME_ACTIVE);\n      this._isSliding = false;\n      triggerSlidEvent();\n    }\n\n    if (isCycling) {\n      this.cycle();\n    }\n  }\n\n  _directionToOrder(direction) {\n    if (![DIRECTION_RIGHT, DIRECTION_LEFT].includes(direction)) {\n      return direction;\n    }\n\n    if (isRTL()) {\n      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\n    }\n\n    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\n  }\n\n  _orderToDirection(order) {\n    if (![ORDER_NEXT, ORDER_PREV].includes(order)) {\n      return order;\n    }\n\n    if (isRTL()) {\n      return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n\n    return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\n  } // Static\n\n\n  static carouselInterface(element, config) {\n    const data = Carousel.getOrCreateInstance(element, config);\n    let {\n      _config\n    } = data;\n\n    if (typeof config === 'object') {\n      _config = { ..._config,\n        ...config\n      };\n    }\n\n    const action = typeof config === 'string' ? config : _config.slide;\n\n    if (typeof config === 'number') {\n      data.to(config);\n    } else if (typeof action === 'string') {\n      if (typeof data[action] === 'undefined') {\n        throw new TypeError(`No method named \"${action}\"`);\n      }\n\n      data[action]();\n    } else if (_config.interval && _config.ride) {\n      data.pause();\n      data.cycle();\n    }\n  }\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      Carousel.carouselInterface(this, config);\n    });\n  }\n\n  static dataApiClickHandler(event) {\n    const target = getElementFromSelector(this);\n\n    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\n      return;\n    }\n\n    const config = { ...Manipulator.getDataAttributes(target),\n      ...Manipulator.getDataAttributes(this)\n    };\n    const slideIndex = this.getAttribute('data-bs-slide-to');\n\n    if (slideIndex) {\n      config.interval = false;\n    }\n\n    Carousel.carouselInterface(target, config);\n\n    if (slideIndex) {\n      Carousel.getInstance(target).to(slideIndex);\n    }\n\n    event.preventDefault();\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler);\nEventHandler.on(window, EVENT_LOAD_DATA_API, () => {\n  const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);\n\n  for (let i = 0, len = carousels.length; i < len; i++) {\n    Carousel.carouselInterface(carousels[i], Carousel.getInstance(carousels[i]));\n  }\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Carousel to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(Carousel);\nexport default Carousel;","map":{"version":3,"sources":["/Users/kurt/workspace/work/shop/node_modules/bootstrap/js/src/carousel.js"],"names":["defineJQueryPlugin","getElementFromSelector","isRTL","isVisible","getNextActiveElement","reflow","triggerTransitionEnd","typeCheckConfig","EventHandler","Manipulator","SelectorEngine","BaseComponent","NAME","DATA_KEY","EVENT_KEY","DATA_API_KEY","ARROW_LEFT_KEY","ARROW_RIGHT_KEY","TOUCHEVENT_COMPAT_WAIT","SWIPE_THRESHOLD","Default","interval","keyboard","slide","pause","wrap","touch","DefaultType","ORDER_NEXT","ORDER_PREV","DIRECTION_LEFT","DIRECTION_RIGHT","KEY_TO_DIRECTION","EVENT_SLIDE","EVENT_SLID","EVENT_KEYDOWN","EVENT_MOUSEENTER","EVENT_MOUSELEAVE","EVENT_TOUCHSTART","EVENT_TOUCHMOVE","EVENT_TOUCHEND","EVENT_POINTERDOWN","EVENT_POINTERUP","EVENT_DRAG_START","EVENT_LOAD_DATA_API","EVENT_CLICK_DATA_API","CLASS_NAME_CAROUSEL","CLASS_NAME_ACTIVE","CLASS_NAME_SLIDE","CLASS_NAME_END","CLASS_NAME_START","CLASS_NAME_NEXT","CLASS_NAME_PREV","CLASS_NAME_POINTER_EVENT","SELECTOR_ACTIVE","SELECTOR_ACTIVE_ITEM","SELECTOR_ITEM","SELECTOR_ITEM_IMG","SELECTOR_NEXT_PREV","SELECTOR_INDICATORS","SELECTOR_INDICATOR","SELECTOR_DATA_SLIDE","SELECTOR_DATA_RIDE","POINTER_TYPE_TOUCH","POINTER_TYPE_PEN","Carousel","constructor","element","config","_items","_interval","_activeElement","_isPaused","_isSliding","touchTimeout","touchStartX","touchDeltaX","_config","_getConfig","_indicatorsElement","findOne","_element","_touchSupported","document","documentElement","navigator","maxTouchPoints","_pointerEvent","Boolean","window","PointerEvent","_addEventListeners","next","_slide","nextWhenVisible","hidden","prev","event","cycle","clearInterval","_updateInterval","setInterval","visibilityState","bind","to","index","activeIndex","_getItemIndex","length","one","order","getDataAttributes","_handleSwipe","absDeltax","Math","abs","direction","on","_keydown","_addTouchEventListeners","hasPointerPenTouch","pointerType","start","clientX","touches","move","end","clearTimeout","setTimeout","find","forEach","itemImg","preventDefault","classList","add","test","target","tagName","key","parentNode","indexOf","_getItemByOrder","activeElement","isNext","_triggerSlideEvent","relatedTarget","eventDirectionName","targetIndex","fromIndex","trigger","from","_setActiveIndicatorElement","activeIndicator","remove","removeAttribute","indicators","i","Number","parseInt","getAttribute","setAttribute","elementInterval","defaultInterval","directionOrOrder","_directionToOrder","activeElementIndex","nextElement","nextElementIndex","isCycling","directionalClassName","orderClassName","_orderToDirection","contains","slideEvent","defaultPrevented","triggerSlidEvent","completeCallBack","_queueCallback","includes","carouselInterface","data","getOrCreateInstance","action","TypeError","ride","jQueryInterface","each","dataApiClickHandler","slideIndex","getInstance","carousels","len"],"mappings":"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","sourcesContent":["/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.1.3): carousel.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nimport {\n  defineJQueryPlugin,\n  getElementFromSelector,\n  isRTL,\n  isVisible,\n  getNextActiveElement,\n  reflow,\n  triggerTransitionEnd,\n  typeCheckConfig\n} from './util/index'\nimport EventHandler from './dom/event-handler'\nimport Manipulator from './dom/manipulator'\nimport SelectorEngine from './dom/selector-engine'\nimport BaseComponent from './base-component'\n\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME = 'carousel'\nconst DATA_KEY = 'bs.carousel'\nconst EVENT_KEY = `.${DATA_KEY}`\nconst DATA_API_KEY = '.data-api'\n\nconst ARROW_LEFT_KEY = 'ArrowLeft'\nconst ARROW_RIGHT_KEY = 'ArrowRight'\nconst TOUCHEVENT_COMPAT_WAIT = 500 // Time for mouse compat events to fire after touch\nconst SWIPE_THRESHOLD = 40\n\nconst Default = {\n  interval: 5000,\n  keyboard: true,\n  slide: false,\n  pause: 'hover',\n  wrap: true,\n  touch: true\n}\n\nconst DefaultType = {\n  interval: '(number|boolean)',\n  keyboard: 'boolean',\n  slide: '(boolean|string)',\n  pause: '(string|boolean)',\n  wrap: 'boolean',\n  touch: 'boolean'\n}\n\nconst ORDER_NEXT = 'next'\nconst ORDER_PREV = 'prev'\nconst DIRECTION_LEFT = 'left'\nconst DIRECTION_RIGHT = 'right'\n\nconst KEY_TO_DIRECTION = {\n  [ARROW_LEFT_KEY]: DIRECTION_RIGHT,\n  [ARROW_RIGHT_KEY]: DIRECTION_LEFT\n}\n\nconst EVENT_SLIDE = `slide${EVENT_KEY}`\nconst EVENT_SLID = `slid${EVENT_KEY}`\nconst EVENT_KEYDOWN = `keydown${EVENT_KEY}`\nconst EVENT_MOUSEENTER = `mouseenter${EVENT_KEY}`\nconst EVENT_MOUSELEAVE = `mouseleave${EVENT_KEY}`\nconst EVENT_TOUCHSTART = `touchstart${EVENT_KEY}`\nconst EVENT_TOUCHMOVE = `touchmove${EVENT_KEY}`\nconst EVENT_TOUCHEND = `touchend${EVENT_KEY}`\nconst EVENT_POINTERDOWN = `pointerdown${EVENT_KEY}`\nconst EVENT_POINTERUP = `pointerup${EVENT_KEY}`\nconst EVENT_DRAG_START = `dragstart${EVENT_KEY}`\nconst EVENT_LOAD_DATA_API = `load${EVENT_KEY}${DATA_API_KEY}`\nconst EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`\n\nconst CLASS_NAME_CAROUSEL = 'carousel'\nconst CLASS_NAME_ACTIVE = 'active'\nconst CLASS_NAME_SLIDE = 'slide'\nconst CLASS_NAME_END = 'carousel-item-end'\nconst CLASS_NAME_START = 'carousel-item-start'\nconst CLASS_NAME_NEXT = 'carousel-item-next'\nconst CLASS_NAME_PREV = 'carousel-item-prev'\nconst CLASS_NAME_POINTER_EVENT = 'pointer-event'\n\nconst SELECTOR_ACTIVE = '.active'\nconst SELECTOR_ACTIVE_ITEM = '.active.carousel-item'\nconst SELECTOR_ITEM = '.carousel-item'\nconst SELECTOR_ITEM_IMG = '.carousel-item img'\nconst SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev'\nconst SELECTOR_INDICATORS = '.carousel-indicators'\nconst SELECTOR_INDICATOR = '[data-bs-target]'\nconst SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]'\nconst SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]'\n\nconst POINTER_TYPE_TOUCH = 'touch'\nconst POINTER_TYPE_PEN = 'pen'\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\nclass Carousel extends BaseComponent {\n  constructor(element, config) {\n    super(element)\n\n    this._items = null\n    this._interval = null\n    this._activeElement = null\n    this._isPaused = false\n    this._isSliding = false\n    this.touchTimeout = null\n    this.touchStartX = 0\n    this.touchDeltaX = 0\n\n    this._config = this._getConfig(config)\n    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element)\n    this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0\n    this._pointerEvent = Boolean(window.PointerEvent)\n\n    this._addEventListeners()\n  }\n\n  // Getters\n\n  static get Default() {\n    return Default\n  }\n\n  static get NAME() {\n    return NAME\n  }\n\n  // Public\n\n  next() {\n    this._slide(ORDER_NEXT)\n  }\n\n  nextWhenVisible() {\n    // Don't call next when the page isn't visible\n    // or the carousel or its parent isn't visible\n    if (!document.hidden && isVisible(this._element)) {\n      this.next()\n    }\n  }\n\n  prev() {\n    this._slide(ORDER_PREV)\n  }\n\n  pause(event) {\n    if (!event) {\n      this._isPaused = true\n    }\n\n    if (SelectorEngine.findOne(SELECTOR_NEXT_PREV, this._element)) {\n      triggerTransitionEnd(this._element)\n      this.cycle(true)\n    }\n\n    clearInterval(this._interval)\n    this._interval = null\n  }\n\n  cycle(event) {\n    if (!event) {\n      this._isPaused = false\n    }\n\n    if (this._interval) {\n      clearInterval(this._interval)\n      this._interval = null\n    }\n\n    if (this._config && this._config.interval && !this._isPaused) {\n      this._updateInterval()\n\n      this._interval = setInterval(\n        (document.visibilityState ? this.nextWhenVisible : this.next).bind(this),\n        this._config.interval\n      )\n    }\n  }\n\n  to(index) {\n    this._activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element)\n    const activeIndex = this._getItemIndex(this._activeElement)\n\n    if (index > this._items.length - 1 || index < 0) {\n      return\n    }\n\n    if (this._isSliding) {\n      EventHandler.one(this._element, EVENT_SLID, () => this.to(index))\n      return\n    }\n\n    if (activeIndex === index) {\n      this.pause()\n      this.cycle()\n      return\n    }\n\n    const order = index > activeIndex ?\n      ORDER_NEXT :\n      ORDER_PREV\n\n    this._slide(order, this._items[index])\n  }\n\n  // Private\n\n  _getConfig(config) {\n    config = {\n      ...Default,\n      ...Manipulator.getDataAttributes(this._element),\n      ...(typeof config === 'object' ? config : {})\n    }\n    typeCheckConfig(NAME, config, DefaultType)\n    return config\n  }\n\n  _handleSwipe() {\n    const absDeltax = Math.abs(this.touchDeltaX)\n\n    if (absDeltax <= SWIPE_THRESHOLD) {\n      return\n    }\n\n    const direction = absDeltax / this.touchDeltaX\n\n    this.touchDeltaX = 0\n\n    if (!direction) {\n      return\n    }\n\n    this._slide(direction > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT)\n  }\n\n  _addEventListeners() {\n    if (this._config.keyboard) {\n      EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event))\n    }\n\n    if (this._config.pause === 'hover') {\n      EventHandler.on(this._element, EVENT_MOUSEENTER, event => this.pause(event))\n      EventHandler.on(this._element, EVENT_MOUSELEAVE, event => this.cycle(event))\n    }\n\n    if (this._config.touch && this._touchSupported) {\n      this._addTouchEventListeners()\n    }\n  }\n\n  _addTouchEventListeners() {\n    const hasPointerPenTouch = event => {\n      return this._pointerEvent &&\n        (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)\n    }\n\n    const start = event => {\n      if (hasPointerPenTouch(event)) {\n        this.touchStartX = event.clientX\n      } else if (!this._pointerEvent) {\n        this.touchStartX = event.touches[0].clientX\n      }\n    }\n\n    const move = event => {\n      // ensure swiping with one touch and not pinching\n      this.touchDeltaX = event.touches && event.touches.length > 1 ?\n        0 :\n        event.touches[0].clientX - this.touchStartX\n    }\n\n    const end = event => {\n      if (hasPointerPenTouch(event)) {\n        this.touchDeltaX = event.clientX - this.touchStartX\n      }\n\n      this._handleSwipe()\n      if (this._config.pause === 'hover') {\n        // If it's a touch-enabled device, mouseenter/leave are fired as\n        // part of the mouse compatibility events on first tap - the carousel\n        // would stop cycling until user tapped out of it;\n        // here, we listen for touchend, explicitly pause the carousel\n        // (as if it's the second time we tap on it, mouseenter compat event\n        // is NOT fired) and after a timeout (to allow for mouse compatibility\n        // events to fire) we explicitly restart cycling\n\n        this.pause()\n        if (this.touchTimeout) {\n          clearTimeout(this.touchTimeout)\n        }\n\n        this.touchTimeout = setTimeout(event => this.cycle(event), TOUCHEVENT_COMPAT_WAIT + this._config.interval)\n      }\n    }\n\n    SelectorEngine.find(SELECTOR_ITEM_IMG, this._element).forEach(itemImg => {\n      EventHandler.on(itemImg, EVENT_DRAG_START, event => event.preventDefault())\n    })\n\n    if (this._pointerEvent) {\n      EventHandler.on(this._element, EVENT_POINTERDOWN, event => start(event))\n      EventHandler.on(this._element, EVENT_POINTERUP, event => end(event))\n\n      this._element.classList.add(CLASS_NAME_POINTER_EVENT)\n    } else {\n      EventHandler.on(this._element, EVENT_TOUCHSTART, event => start(event))\n      EventHandler.on(this._element, EVENT_TOUCHMOVE, event => move(event))\n      EventHandler.on(this._element, EVENT_TOUCHEND, event => end(event))\n    }\n  }\n\n  _keydown(event) {\n    if (/input|textarea/i.test(event.target.tagName)) {\n      return\n    }\n\n    const direction = KEY_TO_DIRECTION[event.key]\n    if (direction) {\n      event.preventDefault()\n      this._slide(direction)\n    }\n  }\n\n  _getItemIndex(element) {\n    this._items = element && element.parentNode ?\n      SelectorEngine.find(SELECTOR_ITEM, element.parentNode) :\n      []\n\n    return this._items.indexOf(element)\n  }\n\n  _getItemByOrder(order, activeElement) {\n    const isNext = order === ORDER_NEXT\n    return getNextActiveElement(this._items, activeElement, isNext, this._config.wrap)\n  }\n\n  _triggerSlideEvent(relatedTarget, eventDirectionName) {\n    const targetIndex = this._getItemIndex(relatedTarget)\n    const fromIndex = this._getItemIndex(SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element))\n\n    return EventHandler.trigger(this._element, EVENT_SLIDE, {\n      relatedTarget,\n      direction: eventDirectionName,\n      from: fromIndex,\n      to: targetIndex\n    })\n  }\n\n  _setActiveIndicatorElement(element) {\n    if (this._indicatorsElement) {\n      const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement)\n\n      activeIndicator.classList.remove(CLASS_NAME_ACTIVE)\n      activeIndicator.removeAttribute('aria-current')\n\n      const indicators = SelectorEngine.find(SELECTOR_INDICATOR, this._indicatorsElement)\n\n      for (let i = 0; i < indicators.length; i++) {\n        if (Number.parseInt(indicators[i].getAttribute('data-bs-slide-to'), 10) === this._getItemIndex(element)) {\n          indicators[i].classList.add(CLASS_NAME_ACTIVE)\n          indicators[i].setAttribute('aria-current', 'true')\n          break\n        }\n      }\n    }\n  }\n\n  _updateInterval() {\n    const element = this._activeElement || SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element)\n\n    if (!element) {\n      return\n    }\n\n    const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10)\n\n    if (elementInterval) {\n      this._config.defaultInterval = this._config.defaultInterval || this._config.interval\n      this._config.interval = elementInterval\n    } else {\n      this._config.interval = this._config.defaultInterval || this._config.interval\n    }\n  }\n\n  _slide(directionOrOrder, element) {\n    const order = this._directionToOrder(directionOrOrder)\n    const activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element)\n    const activeElementIndex = this._getItemIndex(activeElement)\n    const nextElement = element || this._getItemByOrder(order, activeElement)\n\n    const nextElementIndex = this._getItemIndex(nextElement)\n    const isCycling = Boolean(this._interval)\n\n    const isNext = order === ORDER_NEXT\n    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END\n    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV\n    const eventDirectionName = this._orderToDirection(order)\n\n    if (nextElement && nextElement.classList.contains(CLASS_NAME_ACTIVE)) {\n      this._isSliding = false\n      return\n    }\n\n    if (this._isSliding) {\n      return\n    }\n\n    const slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName)\n    if (slideEvent.defaultPrevented) {\n      return\n    }\n\n    if (!activeElement || !nextElement) {\n      // Some weirdness is happening, so we bail\n      return\n    }\n\n    this._isSliding = true\n\n    if (isCycling) {\n      this.pause()\n    }\n\n    this._setActiveIndicatorElement(nextElement)\n    this._activeElement = nextElement\n\n    const triggerSlidEvent = () => {\n      EventHandler.trigger(this._element, EVENT_SLID, {\n        relatedTarget: nextElement,\n        direction: eventDirectionName,\n        from: activeElementIndex,\n        to: nextElementIndex\n      })\n    }\n\n    if (this._element.classList.contains(CLASS_NAME_SLIDE)) {\n      nextElement.classList.add(orderClassName)\n\n      reflow(nextElement)\n\n      activeElement.classList.add(directionalClassName)\n      nextElement.classList.add(directionalClassName)\n\n      const completeCallBack = () => {\n        nextElement.classList.remove(directionalClassName, orderClassName)\n        nextElement.classList.add(CLASS_NAME_ACTIVE)\n\n        activeElement.classList.remove(CLASS_NAME_ACTIVE, orderClassName, directionalClassName)\n\n        this._isSliding = false\n\n        setTimeout(triggerSlidEvent, 0)\n      }\n\n      this._queueCallback(completeCallBack, activeElement, true)\n    } else {\n      activeElement.classList.remove(CLASS_NAME_ACTIVE)\n      nextElement.classList.add(CLASS_NAME_ACTIVE)\n\n      this._isSliding = false\n      triggerSlidEvent()\n    }\n\n    if (isCycling) {\n      this.cycle()\n    }\n  }\n\n  _directionToOrder(direction) {\n    if (![DIRECTION_RIGHT, DIRECTION_LEFT].includes(direction)) {\n      return direction\n    }\n\n    if (isRTL()) {\n      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT\n    }\n\n    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV\n  }\n\n  _orderToDirection(order) {\n    if (![ORDER_NEXT, ORDER_PREV].includes(order)) {\n      return order\n    }\n\n    if (isRTL()) {\n      return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT\n    }\n\n    return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT\n  }\n\n  // Static\n\n  static carouselInterface(element, config) {\n    const data = Carousel.getOrCreateInstance(element, config)\n\n    let { _config } = data\n    if (typeof config === 'object') {\n      _config = {\n        ..._config,\n        ...config\n      }\n    }\n\n    const action = typeof config === 'string' ? config : _config.slide\n\n    if (typeof config === 'number') {\n      data.to(config)\n    } else if (typeof action === 'string') {\n      if (typeof data[action] === 'undefined') {\n        throw new TypeError(`No method named \"${action}\"`)\n      }\n\n      data[action]()\n    } else if (_config.interval && _config.ride) {\n      data.pause()\n      data.cycle()\n    }\n  }\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      Carousel.carouselInterface(this, config)\n    })\n  }\n\n  static dataApiClickHandler(event) {\n    const target = getElementFromSelector(this)\n\n    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\n      return\n    }\n\n    const config = {\n      ...Manipulator.getDataAttributes(target),\n      ...Manipulator.getDataAttributes(this)\n    }\n    const slideIndex = this.getAttribute('data-bs-slide-to')\n\n    if (slideIndex) {\n      config.interval = false\n    }\n\n    Carousel.carouselInterface(target, config)\n\n    if (slideIndex) {\n      Carousel.getInstance(target).to(slideIndex)\n    }\n\n    event.preventDefault()\n  }\n}\n\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\nEventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler)\n\nEventHandler.on(window, EVENT_LOAD_DATA_API, () => {\n  const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE)\n\n  for (let i = 0, len = carousels.length; i < len; i++) {\n    Carousel.carouselInterface(carousels[i], Carousel.getInstance(carousels[i]))\n  }\n})\n\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Carousel to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(Carousel)\n\nexport default Carousel\n"]},"metadata":{},"sourceType":"module"}